import { PublicKey, SystemProgram } from "@solana/web3.js";
import { BN } from "@coral-xyz/anchor";

/**
 * Instruction discriminators from IDL
 * These are generated by Anchor and MUST match exactly
 * Generated from target/idl/dive_game.json
 * Last synced: Tue 18 Nov 2025 22:52:37 EST
 */
export const DISCRIMINATORS = {
  CASH_OUT: Buffer.from([1, 110, 57, 58, 159, 157, 243, 192]),
  CLEAN_EXPIRED_SESSION: Buffer.from([198, 119, 17, 15, 128, 185, 80, 231]),
  INIT_CONFIG: Buffer.from([23, 235, 115, 232, 168, 96, 1, 231]),
  INIT_HOUSE_VAULT: Buffer.from([82, 247, 65, 25, 166, 239, 30, 112]),
  LOSE_SESSION: Buffer.from([13, 163, 66, 150, 39, 65, 34, 53]),
  PLAY_ROUND: Buffer.from([38, 35, 89, 4, 59, 139, 225, 250]),
  START_SESSION: Buffer.from([23, 227, 111, 142, 212, 230, 3, 175]),
  TOGGLE_HOUSE_LOCK: Buffer.from([170, 63, 166, 115, 196, 253, 239, 115]),
  WITHDRAW_HOUSE: Buffer.from([226, 236, 222, 156, 198, 230, 70, 147]),
};

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Serialize an Option<T> field for Anchor instruction data
 * - None: [0]
 * - Some(value): [1, ...value_bytes]
 */
function serializeOption(
  value: number | BN | bigint | undefined | null,
  byteLength: number
): Buffer {
  if (value === undefined || value === null) {
    // None variant
    return Buffer.from([0]);
  }

  // Some variant
  const valueBN = value instanceof BN ? value : new BN(value.toString());
  const valueBytes = valueBN.toArrayLike(Buffer, "le", byteLength);
  return Buffer.concat([Buffer.from([1]), valueBytes]);
}

// ============================================================================
// Instruction Data Builders
// ============================================================================

/**
 * Build init_config instruction data
 * All parameters are Option<T> - pass undefined/null to use defaults
 */
export function buildInitConfigData(params: {
  baseSurvivalPpm?: number;
  decayPerDivePpm?: number;
  minSurvivalPpm?: number;
  treasureMultiplierNum?: number;
  treasureMultiplierDen?: number;
  maxPayoutMultiplier?: number;
  maxDives?: number;
  minBet?: BN | bigint;
  maxBet?: BN | bigint;
}): Buffer {
  return Buffer.concat([
    DISCRIMINATORS.INIT_CONFIG,
    serializeOption(params.baseSurvivalPpm, 4), // Option<u32>
    serializeOption(params.decayPerDivePpm, 4), // Option<u32>
    serializeOption(params.minSurvivalPpm, 4), // Option<u32>
    serializeOption(params.treasureMultiplierNum, 2), // Option<u16>
    serializeOption(params.treasureMultiplierDen, 2), // Option<u16>
    serializeOption(params.maxPayoutMultiplier, 2), // Option<u16>
    serializeOption(params.maxDives, 2), // Option<u16>
    serializeOption(params.minBet, 8), // Option<u64>
    serializeOption(params.maxBet, 8), // Option<u64>
  ]);
}

/**
 * Build init_house_vault instruction data
 */
export function buildInitHouseVaultData(locked: boolean): Buffer {
  const lockedByte = Buffer.from([locked ? 1 : 0]);
  return Buffer.concat([DISCRIMINATORS.INIT_HOUSE_VAULT, lockedByte]);
}

/**
 * Build start_session instruction data
 */
export function buildStartSessionData(
  betAmount: BN | bigint,
  sessionIndex: BN | bigint | number
): Buffer {
  const betBN = BN.isBN(betAmount) ? betAmount : new BN(betAmount.toString());
  const indexBN =
    typeof sessionIndex === "number"
      ? new BN(sessionIndex)
      : BN.isBN(sessionIndex)
        ? sessionIndex
        : new BN(sessionIndex.toString());

  const betBytes = betBN.toArrayLike(Buffer, "le", 8);
  const indexBytes = indexBN.toArrayLike(Buffer, "le", 8);

  return Buffer.concat([DISCRIMINATORS.START_SESSION, betBytes, indexBytes]);
}

/**
 * Build play_round instruction data (no parameters)
 */
export function buildPlayRoundData(): Buffer {
  return DISCRIMINATORS.PLAY_ROUND;
}

/**
 * Build cash_out instruction data (no parameters)
 */
export function buildCashOutData(): Buffer {
  return DISCRIMINATORS.CASH_OUT;
}

/**
 * Build lose_session instruction data (no parameters)
 */
export function buildLoseSessionData(): Buffer {
  return DISCRIMINATORS.LOSE_SESSION;
}

/**
 * Build toggle_house_lock instruction data (no parameters)
 */
export function buildToggleHouseLockData(): Buffer {
  return DISCRIMINATORS.TOGGLE_HOUSE_LOCK;
}

// ============================================================================
// System Program Helper
// ============================================================================

/**
 * Get system program ID for convenience
 */
export function getSystemProgramId(): PublicKey {
  return SystemProgram.programId;
}

// ============================================================================
// Re-exports and Wrappers (Added manually - do not remove!)
// ============================================================================

import {
  getGameConfigAddress,
  getHouseVaultAddress,
  getSessionAddress,
} from "../solana/pdas";
import { lamportsToSol, solToLamports } from "../utils/lamports";

// Program ID from environment
// Using lazy initialization to avoid build-time instantiation issues
let _programId: PublicKey | undefined;
function getProgramId(): PublicKey {
  if (!_programId) {
    // Get env var and validate it's not empty
    let programIdStr = process.env.NEXT_PUBLIC_PROGRAM_ID;
    if (!programIdStr || programIdStr.trim() === "") {
      programIdStr = "9GxDuBwkkzJWe7ij6xrYv5FFAuqkDW5hjtripZAJgKb7";
    }
    try {
      _programId = new PublicKey(programIdStr);
    } catch (error) {
      console.error(
        `[solanaHelpers] Invalid PROGRAM_ID: "${programIdStr}", using fallback`
      );
      _programId = new PublicKey(
        "9GxDuBwkkzJWe7ij6xrYv5FFAuqkDW5hjtripZAJgKb7"
      );
    }
  }
  return _programId;
}

// Export using a getter property that calls getProgramId
// This ensures no PublicKey is instantiated at module load time
export { getProgramId as PROGRAM_ID };

// PDA helper wrappers that return just the address (not tuple)
export function getConfigPDA(): PublicKey {
  const [pda] = getGameConfigAddress(getProgramId());
  return pda;
}

export function getHouseVaultPDA(houseAuthority: PublicKey): PublicKey {
  const [pda] = getHouseVaultAddress(houseAuthority, getProgramId());
  return pda;
}

export function getSessionPDA(
  user: PublicKey,
  sessionIndex: bigint | number
): PublicKey {
  const [pda] = getSessionAddress(user, sessionIndex, getProgramId());
  return pda;
}

// Export lamport utilities
export { lamportsToSol, solToLamports };
